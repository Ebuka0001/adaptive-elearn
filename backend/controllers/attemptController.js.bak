// controllers/attemptController.js
const mongoose = require('mongoose');
const Attempt = require('../models/Attempt');
const Question = require('../models/Question');
const User = require('../models/User');
const adaptiveService = require('../services/adaptiveService');
const badgeService = require('../services/badgeService');
const { calculateReward } = require('../services/rewardService');

// small helper to protect external service calls (timeout)
function withTimeout(promise, ms = 4000, label = 'operation') {
  return Promise.race([
    promise,
    new Promise((_, reject) => setTimeout(() => reject(new Error(`${label} timed out after ${ms}ms`)), ms))
  ]);
}

async function tryStartSession() {
  try {
    if (!mongoose.connection.client || !mongoose.connection.client.topology) return null;
    const session = await mongoose.startSession();
    session.startTransaction();
    return session;
  } catch (e) {
    return null; // fallback to no session
  }
}

exports.submitAttempt = async (req, res) => {
  const { questionId, givenAnswer, timeSeconds = 0 } = req.body || {};

  try {
    if (!questionId) return res.status(400).json({ message: 'questionId is required' });
    if (!mongoose.Types.ObjectId.isValid(questionId)) return res.status(400).json({ message: 'questionId is not a valid id' });

    // attempt to start a transaction; if not available, proceed without
    const session = await tryStartSession();

    // Fetch question (use session if present)
    const question = await Question.findById(questionId).session ? await Question.findById(questionId).session(session || null) : await Question.findById(questionId);
    if (!question) {
      if (session) { await session.abortTransaction(); session.endSession(); }
      return res.status(404).json({ message: 'Question not found' });
    }

    // Evaluate correctness
    let correct = false;
    if (question.type === 'mcq') {
      const correctChoice = (question.choices || []).find(c => c.correct);
      correct = !!(correctChoice && String(correctChoice.text).trim() === String(givenAnswer || '').trim());
    } else {
      correct = String(question.answer || '').trim().toLowerCase() === String(givenAnswer || '').trim().toLowerCase();
    }

    // Get (fresh) user doc
    const user = session
      ? await User.findById(req.user._id).session(session)
      : await User.findById(req.user._id);
    if (!user) {
      if (session) { await session.abortTransaction(); session.endSession(); }
      return res.status(500).json({ message: 'User not found (during attempt)' });
    }

    // calculate reward deterministically (use your rewardService)
    const pointsToAward = calculateReward({
      correct,
      difficulty: question.difficulty || 1,
      timeSeconds,
      base: question.points || 10,
      streak: user.currentStreak || 0
    });

    // create attempt record (audit)
    let attemptDoc;
    if (session) {
      const arr = await Attempt.create([{
        student: user._id,
        question: question._id,
        correct,
        givenAnswer,
        pointsEarned: pointsToAward,
        timeSeconds
      }], { session });
      attemptDoc = arr[0];
    } else {
      attemptDoc = await Attempt.create({
        student: user._id,
        question: question._id,
        correct,
        givenAnswer,
        pointsEarned: pointsToAward,
        timeSeconds
      });
    }

    // Update user points/level/streak in an atomic-ish way:
    try {
      if (session) {
        // update fields on user doc and save in session
        if (pointsToAward > 0) {
          user.points = (user.points || 0) + pointsToAward;
          user.level = Math.floor((user.points) / 100) + 1;
        }
        user.currentStreak = correct ? ((user.currentStreak || 0) + 1) : 0;
        await user.save({ session });
      } else {
        // fallback: use findByIdAndUpdate with $inc and $set to avoid race
        const update = {};
        if (pointsToAward > 0) update.$inc = { points: pointsToAward };
        update.$set = { currentStreak: correct ? ((user.currentStreak || 0) + 1) : 0 };
        // compute new level from previous points + increment (best-effort)
        const newPoints = (user.points || 0) + (pointsToAward || 0);
        update.$set.level = Math.floor(newPoints / 100) + 1;
        const updated = await User.findByIdAndUpdate(user._id, update, { new: true });
        // copy back for response
        user.points = updated.points;
        user.level = updated.level;
        user.currentStreak = updated.currentStreak;
      }
    } catch (uErr) {
      // non-fatal: log and continue (we already have an attempt record)
      console.error('user update error (non-fatal):', uErr && uErr.message ? uErr.message : uErr);
    }

    // Call adaptiveService and badgeService but guard them with timeouts.
    let awardedBadges = [];
    try {
      if (adaptiveService && typeof adaptiveService.updateMastery === 'function') {
        // pass session when available
        await withTimeout(adaptiveService.updateMastery(user, question.concepts || [], correct, question.difficulty || 1, { session }), 4000, 'adaptive.updateMastery');
      }
    } catch (ae) {
      console.error('adaptiveService.updateMastery error (non-fatal):', ae && ae.message ? ae.message : ae);
    }

    try {
      if (badgeService && typeof badgeService.checkBadges === 'function') {
        awardedBadges = await withTimeout(badgeService.checkBadges(user, { session }), 4000, 'badge.checkBadges');
        // ensure it's an array
        awardedBadges = Array.isArray(awardedBadges) ? awardedBadges : [];
      }
    } catch (be) {
      console.error('badgeService.checkBadges error (non-fatal):', be && be.message ? be.message : be);
      awardedBadges = [];
    }

    // commit if using session
    if (session) {
      try {
        await session.commitTransaction();
      } catch (commitErr) {
        console.error('commit transaction failed:', commitErr && commitErr.message ? commitErr.message : commitErr);
        try { await session.abortTransaction(); } catch (e) { /* ignore */ }
      } finally {
        session.endSession();
      }
    }

    // return result with consistent shape
    return res.json({
      attempt: attemptDoc,
      user: {
        id: user._id,
        name: user.name,
        points: user.points,
        level: user.level,
        mastery: user.mastery,
        badges: user.badges
      },
      awardedBadges
    });
  } catch (err) {
    console.error('submitAttempt error:', err && (err.stack || err.message) ? (err.stack || err.message) : err);
    return res.status(500).json({ message: 'Server error' });
  }
};

exports.getAttemptsForStudent = async (req, res) => {
  try {
    const attempts = await Attempt.find({ student: req.params.studentId }).populate('question');
    res.json(attempts);
  } catch (err) {
    console.error('getAttemptsForStudent error:', err && err.stack ? err.stack : err);
    res.status(500).json({ message: 'Server error' });
  }
};